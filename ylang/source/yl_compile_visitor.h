//
//  yl_compile_visitor.h
//
//  Created by Edmund Kapusniak on 07/02/2015.
//  Copyright (c) 2015 Edmund Kapusniak. All rights reserved.
//


#ifndef YL_COMPILE_VISITOR_H
#define YL_COMPILE_VISITOR_H


#include "yl_ast_visitor.h"
#include <y_script.h>




/*
    yl uses a register-based virtual machine, which owes a lot to lua.
    
    The original compiler used an SSA-based intermediate representation and
    performed a register allocation pass to minimize moves.
    
    This compiler is much simpler.  The generated bytecode ensures that locals
    are always kept in the same register, and that the register file is used
    in a stack-like manner - all values up to the stack top are live.
    
    This simplifies exception handling, garbage collection, and debug info.
*/



/*
    The compiler's first pass visits the nodes of the AST and produces dumb
    bytecode, as if directly translating the operations of a stack machine.
    This initial bytecode undergoes several optimization passes before it is
    ready to use.
*/




struct yl_compile_script
{
    yl_ast_func*                    func;
    std::vector< yl_ast_node* >     constants;
    std::vector< yl_expr_key* >     keys;
    std::vector< y_opinst >         code;
    std::vector< y_xframe >         xframes;
};



class yl_compile_visitor
    :   private yl_ast_visitor< yl_compile_script, void >
{
public:

    yl_compile_visitor();
    std::unique_ptr< yl_compile_script > compile( yl_ast_func* func );


private:

    
    struct listval
    {
        listval( unsigned r, int count ) : r( r ), count( count ) {}
    
        unsigned    r;
        int         count;
    };
    
    struct lvalue
    {
        lvalue( yl_ast_node_kind kind, unsigned o, unsigned k )
            :   kind( kind ), o( o ), k( k ) {}
    
        yl_ast_node_kind kind;
        unsigned    o;
        unsigned    k;
    };
    
    struct branch
    {
        branch( yl_ast_scope* target ) : target( target ) {}
    
        yl_ast_scope*       target;
        std::vector< int >  jumps;
    };
    
    

    using yl_ast_visitor< yl_compile_script, void >::visit;

    void        fallback( yl_ast_node* node );
    
    void        visit( yl_stmt_block* node );
    void        visit( yl_stmt_if* node );
    void        visit( yl_stmt_switch* node );
    void        visit( yl_stmt_while* node );
    void        visit( yl_stmt_do* node );
    void        visit( yl_stmt_foreach* node );
    void        visit( yl_stmt_for* node );
    void        visit( yl_stmt_using* node );
    void        visit( yl_stmt_try* node );
    void        visit( yl_stmt_catch* node );
    void        visit( yl_stmt_delete* node );
    void        visit( yl_stmt_case* node );
    void        visit( yl_stmt_continue* node );
    void        visit( yl_stmt_break* node );
    void        visit( yl_stmt_return* node );
    void        visit( yl_stmt_throw* node );

    void        visit( yl_ast_func* node );
    void        visit( yl_expr_null* node );
    void        visit( yl_expr_bool* node );
    void        visit( yl_expr_number* node );
    void        visit( yl_expr_string* node );
    void        visit( yl_expr_local* node );
    void        visit( yl_expr_global* node );
    void        visit( yl_expr_upref* node );
    void        visit( yl_expr_objref* node );
    void        visit( yl_expr_superof* node );
    void        visit( yl_expr_key* node );
    void        visit( yl_expr_inkey* node );
    void        visit( yl_expr_index* node );
    void        visit( yl_expr_preop* node );
    void        visit( yl_expr_postop* node );
    void        visit( yl_expr_unary* node );
    void        visit( yl_expr_binary* node );
    void        visit( yl_expr_compare* node );
    void        visit( yl_expr_logical* node );
    void        visit( yl_expr_qmark* node );
    void        visit( yl_new_new* node );
    void        visit( yl_new_object* node );
    void        visit( yl_new_array* node );
    void        visit( yl_new_table* node );
    void        visit( yl_expr_mono* node );
    void        visit( yl_expr_call* node );
    void        visit( yl_expr_yield* node );
    void        visit( yl_expr_vararg* node );
    void        visit( yl_expr_unpack* node );
    void        visit( yl_expr_list* node );
    void        visit( yl_expr_assign* node );
    void        visit( yl_expr_assign_list* node );
    
    void        op( y_opcode op, unsigned r, unsigned a, unsigned b );
    void        op( y_opcode op, unsigned r, unsigned c );
    void        op( y_opcode op, unsigned r, signed j );

    int         jump( y_opcode opcode, unsigned r );
    int         label();
    void        patch( int jump, int label );
    
    void        open_break( yl_ast_scope* target );
    void        add_break( yl_ast_scope* target );
    void        close_break( yl_ast_scope* target, int label );
    void        open_continue( yl_ast_scope* target );
    void        add_continue( yl_ast_scope* target );
    void        close_continue( yl_ast_scope* target, int label );
    
    unsigned    constant( yl_ast_node* node );
    unsigned    key( yl_ast_node* node );
    
    void        execute( yl_ast_node* statement_or_expression );
    
    unsigned    push();
    unsigned    push( yl_ast_node* expression );
    void        pop( unsigned r );
    
    listval     push_list( int count );
    listval     push_list( yl_ast_node* expression, int count );
    void        pop_list( listval lv );
    
    lvalue      push_lvalue( yl_ast_node* lvexpr );
    void        assign( lvalue lv, unsigned v );
    void        pop_lvalue( lvalue lv );
    
    unsigned    push_iterator();
    void        pop_iterator( unsigned i );
    
    void        declare( unsigned r, yl_ast_name* name );
    void        undeclare( yl_ast_scope* scope );


    std::vector< branch >       break_stack;
    std::vector< branch >       continue_stack;
    int                         iterator_stack;

    yl_compile_script*          s;

};




#endif




