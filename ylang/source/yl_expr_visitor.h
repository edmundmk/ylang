//
//  yl_expr_visitor.h
//
//  Created by Edmund Kapusniak on 07/02/2015.
//  Copyright (c) 2015 Edmund Kapusniak. All rights reserved.
//


#ifndef YL_EXPR_VISITOR
#define YL_EXPR_VISITOR


#include "yl_ast_visitor.h"
#include <y_script.h>




/*
    yl uses a register-based virtual machine, which owes a lot to lua.
    
    The original compiler used an SSA-based intermediate representation and
    performed a register allocation pass to minimize moves.
    
    This compiler is much simpler.  The generated bytecode ensures that locals
    are always kept in the same register, and that the register file is used
    in a stack-like manner - all values up to the stack top are live.
    
    This simplifies exception handling, garbage collection, and debug info.
 
*/




class yl_compile_statement;
class yl_compile_expression;
class yl_compile_script;




struct yl_build_script
{
    yl_ast_func*                    func;
    std::vector< yl_ast_node* >     constants;
    std::vector< yl_expr_key* >     keys;
    std::vector< y_opinst >         code;
    std::vector< y_xframe >         xframes;
};






/*
    Visits statement AST nodes and compiles them.
 
*/

class yl_compile_statement
    :   public yl_ast_visitor< yl_compile_statement, void >
{
public:


    yl_compile_statement( yl_compile_script* c );

    using yl_ast_visitor< yl_compile_statement, void >::visit;

    void fallback( yl_ast_node* node );
    
    void visit( yl_stmt_block* node );
    void visit( yl_stmt_if* node );
    void visit( yl_stmt_switch* node );
    void visit( yl_stmt_while* node );
    void visit( yl_stmt_do* node );
    void visit( yl_stmt_foreach* node );
    void visit( yl_stmt_for* node );
    void visit( yl_stmt_using* node );
    void visit( yl_stmt_try* node );
    void visit( yl_stmt_catch* node );
    void visit( yl_stmt_delete* node );
    void visit( yl_stmt_case* node );
    void visit( yl_stmt_continue* node );
    void visit( yl_stmt_break* node );
    void visit( yl_stmt_return* node );
    void visit( yl_stmt_throw* node );


private:

    yl_compile_script* c;


};






/*
    Visits expression AST nodes and compiles them.
*/

class yl_compile_expression
{
public:

    yl_compile_expression( yl_compile_script* c );


private:


    yl_compile_script* c;

};





/*
    Compile an AST representation of a function into a y_script.
    
    The compiler's first pass walks the AST and produces dumb bytecode.  Then
    we run several optimization passes.  We do the optimizations in separate
    passes to simplify the code.
    
        -   Copy propagation, which eliminates unecessary moves and removes
            unused stack slots.  This is the most important optimization pass
            as without it the VM is just an inefficient stack machine.
        
        -   Control flow optimizations, which collapse chains of jumps
            together and can remove unecessary not instructions.
            
        -   Dead code elimination.

*/

class yl_compile_script
{
public:

    yl_compile_script( yl_build_script* s );
    void compile();


private:

    friend class yl_compile_statement;
    friend class yl_compile_expression;
    
    
    struct listval
    {
        listval( unsigned r, int count ) : r( r ), count( count ) {}
    
        unsigned    r;
        int         count;
    };
    
    struct lvalue
    {
        lvalue( yl_ast_node_kind kind, unsigned o, unsigned k )
            :   kind( kind ), o( o ), k( k ) {}
    
        yl_ast_node_kind kind;
        unsigned    o;
        unsigned    k;
    };
    
    struct branch
    {
        branch( yl_ast_scope* target ) : target( target ) {}
    
        yl_ast_scope*       target;
        std::vector< int >  jumps;
    };
    
    
    void        op( y_opcode op, unsigned r, unsigned a, unsigned b );
    void        op( y_opcode op, unsigned r, unsigned c );
    void        op( y_opcode op, unsigned r, signed j );

    int         jump( y_opcode opcode, unsigned r );
    int         label();
    void        patch( int jump, int label );
    
    void        open_break( yl_ast_scope* target );
    void        add_break( yl_ast_scope* target );
    void        close_break( yl_ast_scope* target, int label );
    void        open_continue( yl_ast_scope* target );
    void        add_continue( yl_ast_scope* target );
    void        close_continue( yl_ast_scope* target, int label );
    
    unsigned    constant( yl_ast_node* node );
    unsigned    key( yl_ast_node* node );
    
    unsigned    push();
    unsigned    push( yl_ast_node* expression );
    void        pop( unsigned r );
    
    listval     push_list( int count );
    listval     push_list( yl_ast_node* expression, int count );
    void        pop_list( listval lv );
    
    lvalue      push_lvalue( yl_ast_node* lvexpr );
    void        assign( lvalue lv, unsigned v );
    void        pop_lvalue( lvalue lv );
    
    unsigned    push_iterator();
    void        pop_iterator( unsigned i );
    
    void        declare( unsigned r, yl_ast_name* name );
    void        undeclare( yl_ast_scope* scope );


    yl_compile_statement        compile_statement;
    yl_compile_expression       compile_expression;

    std::vector< branch >       break_stack;
    std::vector< branch >       continue_stack;
    int                         iterator_stack;

    yl_build_script*            s;

};




#endif




